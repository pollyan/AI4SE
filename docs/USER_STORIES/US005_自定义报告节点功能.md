# 用户故事 US005: 自定义报告节点功能 (logScreenshot)

**创建日期**: 2025-01-28  
**优先级**: 中  
**状态**: 需求分析完成  
**预估工作量**: 3-4天  
**MidScene 版本要求**: 0.23.4+

## 📋 需求概述

**背景**: MidScene 0.23.4 版本新增了 `logScreenshot()` API，允许在测试执行过程中的任意时刻添加自定义截图节点，并为其设置个性化的标题和描述内容。这为测试报告增加了强大的自定义能力和更丰富的视觉化记录。

**目标**: 在 Intent Test Framework 中集成自定义报告节点功能，使测试工程师能够主动记录关键测试信息，为不同受众提供层次化的测试报告，大幅提升测试文档的质量和价值。

## 🎯 业务价值

- **测试透明度提升**: 从被动记录转向主动信息捕获，提高测试过程可视化程度 80%+
- **问题诊断效率**: 提供丰富的上下文信息和视觉证据，缩短问题定位时间 50%+
- **报告标准化**: 建立统一的测试报告规范，提高团队协作效率和专业性
- **多受众适配**: 为技术人员和管理人员提供不同层级的信息展示
- **质量追溯链**: 形成完整的测试证据链，提高测试结果可信度和权威性

## 👥 用户画像分析

### 测试工程师
**关注点**: 关键节点记录、问题证据保存、测试思路文档化  
**需求**: 灵活的截图时机控制、丰富的标注功能、标准化的记录格式  

### QA团队领导
**关注点**: 报告质量标准化、团队工作规范、验收文档完整性  
**需求**: 模板管理系统、报告规范制定、质量评估支持  

### 开发团队
**关注点**: 问题重现信息、技术细节获取、修复验证结果  
**需求**: 详细的错误状态、技术上下文信息、清晰的重现步骤  

### 项目干系人
**关注点**: 项目质量状况、风险识别、决策依据  
**需求**: 简化的执行摘要、关键结果展示、专业的演示材料  

## 📊 业务场景分析

### 核心业务场景

1. **关键节点标记**: 在重要验证点、数据准备完成、环境切换等时刻记录状态
2. **错误状态记录**: 发现问题时立即保存现场，避免关键信息丢失
3. **测试思路文档**: 记录测试过程中的假设、验证方法和发现
4. **多受众报告**: 为不同角色生成合适的信息层级和展示格式
5. **证据管理**: 统一管理测试过程中的各种证据和附件材料

## 🚀 用户故事

### 故事1: 测试关键节点记录
**作为** 测试工程师  
**我希望** 在测试执行过程中能够手动添加关键节点的截图和说明  
**以便** 更好地记录测试过程，便于后续分析和问题定位  

**验收条件**:
```gherkin
Given 测试工程师正在执行自动化测试
When 在测试过程中遇到关键步骤或重要状态
Then 能够调用logScreenshot()方法添加自定义报告节点
And 可以为截图设置自定义标题和描述内容
And 截图节点按时间顺序正确插入到测试报告中
And 支持设置节点类型（信息、警告、错误、成功、调试）
And 每个自定义节点在报告中清晰可见且格式统一
And 节点添加不会中断测试执行流程
And 支持在失败重试过程中添加诊断节点
And 节点添加操作的响应时间应小于2秒
```

### 故事2: 错误状态详细记录
**作为** 测试工程师和开发人员  
**我希望** 当测试失败时能够记录详细的错误状态和环境信息  
**以便** 提供充分的调试信息，加快问题解决速度  

**验收条件**:
```gherkin
Given 测试执行过程中遇到错误或异常
When 测试工程师需要记录错误状态
Then 可以快速添加错误状态的截图节点
And 可以记录错误发生时的系统状态信息
And 可以添加错误分析和可能的解决方案建议
And 错误节点在报告中用特殊样式突出显示（红色边框）
And 包含足够的技术细节供开发团队调试使用：
  - 错误发生的准确时间戳
  - 相关的系统日志片段
  - 当前页面的URL和状态
  - 涉及的测试数据
And 支持记录错误的严重程度和影响范围
And 可以关联相关的日志文件和配置信息
And 错误节点应该自动包含浏览器控制台信息
```

### 故事3: 报告模板定制
**作为** QA团队领导  
**我希望** 为不同类型的测试定义标准化的报告模板  
**以便** 确保报告质量一致性，提高团队工作效率  

**验收条件**:
```gherkin
Given QA团队领导需要标准化测试报告格式
When 创建或编辑报告模板
Then 可以定义标准的报告节点类型和格式规范
And 可以设置不同测试类型的默认报告结构：
  - 功能测试模板（准备-验证-结论）
  - 性能测试模板（基准-负载-分析）
  - 安全测试模板（扫描-评估-修复）
And 团队成员使用模板时自动应用预定义格式
And 支持模板的版本管理和团队共享
And 生成的报告符合公司或项目的文档规范
And 可以为模板设置必需和可选的节点类型
And 支持模板的预览和调试功能
And 模板应该包含标准的节点类型定义：
  | 节点类型 | 颜色 | 图标 | 使用场景 |
  | INFO | 蓝色 | 📘 | 重要信息记录 |
  | SUCCESS | 绿色 | ✅ | 验证通过 |
  | WARNING | 橙色 | ⚠️ | 潜在问题 |
  | ERROR | 红色 | ❌ | 错误状态 |
  | DEBUG | 灰色 | 🔧 | 技术调试 |
```

### 故事4: 多受众报告视图
**作为** 项目经理和技术团队成员  
**我希望** 同一个测试报告能够为不同受众提供合适的信息层级  
**以便** 满足不同角色的信息需求，避免信息过载  

**验收条件**:
```gherkin
Given 同一个测试报告需要服务于不同的受众
When 查看测试报告时
Then 技术人员可以查看详细的技术信息和调试数据：
  - 完整的执行日志和错误堆栈
  - 详细的性能数据和资源消耗
  - 完整的截图序列和技术细节
And 管理人员可以查看简化的执行摘要和关键结果：
  - 测试概要和通过率统计
  - 关键问题总结和风险评估
  - 重要截图和结论说明
And 可以通过筛选或折叠功能控制信息显示层级
And 每种视图都保持良好的可读性和专业性
And 支持导出不同详细程度的报告文档（PDF、HTML）
And 可以为不同角色设置默认的视图配置
And 支持快速切换不同的视图模式（技术/管理/演示）
And 视图切换应该在2秒内完成
```

### 故事5: 测试证据管理
**作为** QA团队成员  
**我希望** 统一管理和展示测试过程中收集的各种证据  
**以便** 建立完整的测试追溯链，提高测试可信度  

**验收条件**:
```gherkin
Given QA团队需要管理测试过程中的各种证据
When 收集和组织测试证据时
Then 可以分类管理截图、日志、数据等不同类型的证据：
  - 自动截图（步骤执行后）
  - 自定义截图（关键节点记录）
  - 错误截图（异常状态记录）
  - 系统日志（执行过程记录）
  - 测试数据（输入输出数据）
And 每个证据都有清晰的标签、描述和关联信息
And 支持证据的搜索、筛选和排序功能
And 证据在报告中的展示遵循统一的格式规范
And 支持证据的批量导出和归档备份
And 可以建立证据间的关联关系和依赖链
And 支持证据的权限控制和访问管理
And 证据数据的检索时间应小于3秒
And 支持证据的版本控制和历史追踪
```

### 故事6: 实时报告节点添加
**作为** 测试工程师  
**我希望** 在测试执行过程中能够实时添加报告节点  
**以便** 捕获转瞬即逝的重要状态和信息  

**验收条件**:
```gherkin
Given 测试正在执行中
When 测试工程师发现需要记录的重要信息
Then 可以通过API或界面实时添加报告节点
And 添加操作不会中断或影响测试执行流程
And 报告节点立即出现在实时监控界面中
And 支持快速选择预定义的节点模板
And 支持语音转文字功能用于快速描述录入
And 实时添加的节点应该包含准确的时间戳
And 支持为紧急情况设置快捷键操作
And 节点添加后应该发送通知给相关人员
And 实时添加功能应该有权限控制机制
```

## 🛠️ 技术实现要求

### API 集成设计
1. **midscene_server.js 扩展**
```javascript
// 新增自定义报告节点端点
app.post('/api/log-screenshot', async (req, res) => {
  try {
    const { title, description, nodeType, metadata } = req.body;
    
    // 调用MidScene API
    const result = await agent.logScreenshot(title, {
      content: description,
      type: nodeType || 'INFO',
      metadata: metadata || {}
    });
    
    // 保存到数据库
    const nodeData = await saveCustomNode({
      executionId: getCurrentExecutionId(),
      title,
      description,
      nodeType,
      screenshotPath: result.screenshotPath,
      metadata,
      timestamp: new Date().toISOString()
    });
    
    // 实时通知
    io.emit('custom-node-added', nodeData);
    
    res.json({
      success: true,
      node: nodeData
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// 报告模板管理端点
app.get('/api/report-templates', getReportTemplates);
app.post('/api/report-templates', createReportTemplate);
app.put('/api/report-templates/:id', updateReportTemplate);
```

2. **midscene_python.py 扩展**
```python
class MidSceneAI:
    def log_screenshot(self, title: str, description: str = "", 
                      node_type: str = "INFO", metadata: Dict = None) -> Dict:
        """添加自定义报告节点"""
        print(f"📸 添加报告节点: {title}")
        
        result = self._make_request("/api/log-screenshot", data={
            "title": title,
            "description": description,
            "nodeType": node_type,
            "metadata": metadata or {}
        })
        
        print(f"✅ 报告节点已添加: {node_type}")
        return result.get("node", result)
    
    def log_error_state(self, title: str, error_details: str, 
                       context: Dict = None) -> Dict:
        """专门用于记录错误状态的便捷方法"""
        return self.log_screenshot(
            title=title,
            description=error_details,
            node_type="ERROR",
            metadata={
                "context": context or {},
                "timestamp": datetime.now().isoformat(),
                "severity": "HIGH"
            }
        )
```

### 数据库设计
```sql
-- 自定义报告节点表
CREATE TABLE custom_report_nodes (
    id SERIAL PRIMARY KEY,
    execution_id INTEGER REFERENCES execution_history(id),
    step_execution_id INTEGER REFERENCES step_executions(id) NULL,
    node_type VARCHAR(20) NOT NULL CHECK (node_type IN ('INFO', 'SUCCESS', 'WARNING', 'ERROR', 'DEBUG')),
    title VARCHAR(200) NOT NULL,
    description TEXT,
    screenshot_path VARCHAR(500),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(100),
    display_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true
);

-- 报告模板表
CREATE TABLE report_templates (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    template_config JSONB NOT NULL,
    test_type VARCHAR(50),
    created_by VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    version INTEGER DEFAULT 1
);

-- 模板使用统计表
CREATE TABLE template_usage_stats (
    id SERIAL PRIMARY KEY,
    template_id INTEGER REFERENCES report_templates(id),
    execution_id INTEGER REFERENCES execution_history(id),
    used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_feedback INTEGER CHECK (user_feedback BETWEEN 1 AND 5)
);

-- 创建索引
CREATE INDEX idx_custom_nodes_execution ON custom_report_nodes(execution_id);
CREATE INDEX idx_custom_nodes_type ON custom_report_nodes(node_type);
CREATE INDEX idx_custom_nodes_created_at ON custom_report_nodes(created_at);
```

### 前端界面设计
1. **报告节点添加界面**
```html
<div class="custom-node-panel">
  <div class="node-type-selector">
    <button class="node-type-btn info" data-type="INFO">📘 信息</button>
    <button class="node-type-btn success" data-type="SUCCESS">✅ 成功</button>
    <button class="node-type-btn warning" data-type="WARNING">⚠️ 警告</button>
    <button class="node-type-btn error" data-type="ERROR">❌ 错误</button>
    <button class="node-type-btn debug" data-type="DEBUG">🔧 调试</button>
  </div>
  
  <div class="node-form">
    <input type="text" id="nodeTitle" placeholder="节点标题" required>
    <textarea id="nodeDescription" placeholder="详细描述（可选）"></textarea>
    <div class="metadata-section">
      <label>标签:</label>
      <input type="text" id="nodeTags" placeholder="用逗号分隔">
    </div>
    <div class="actions">
      <button id="addNodeBtn" class="btn btn-primary">添加节点</button>
      <button id="cancelBtn" class="btn btn-ghost">取消</button>
    </div>
  </div>
</div>
```

2. **报告查看界面增强**
```html
<div class="report-viewer">
  <div class="report-toolbar">
    <div class="view-selector">
      <button class="view-btn active" data-view="technical">技术视图</button>
      <button class="view-btn" data-view="management">管理视图</button>
      <button class="view-btn" data-view="presentation">演示视图</button>
    </div>
    <div class="filter-controls">
      <select id="nodeTypeFilter">
        <option value="">所有类型</option>
        <option value="ERROR">仅错误</option>
        <option value="WARNING">仅警告</option>
        <option value="SUCCESS">仅成功</option>
      </select>
    </div>
  </div>
  
  <div class="report-content">
    <div class="execution-summary">
      <!-- 执行摘要 -->
    </div>
    <div class="custom-nodes-section">
      <!-- 自定义节点展示 -->
    </div>
    <div class="standard-steps-section">
      <!-- 标准步骤展示 -->
    </div>
  </div>
</div>
```

## ⚠️ 功能边界和限制

### 技术限制
1. **截图质量**: 受浏览器渲染和网络传输影响
2. **存储容量**: 大量截图会占用相当的存储空间
3. **性能影响**: 频繁的截图操作可能影响测试执行速度
4. **浏览器兼容**: 不同浏览器的截图效果可能存在差异

### 功能约束
1. **实时性限制**: 自定义节点的添加依赖于测试执行状态
2. **权限控制**: 需要合理的权限管理避免滥用
3. **数据一致性**: 确保节点数据与测试执行的关联正确性
4. **模板复杂度**: 过于复杂的模板可能影响易用性

## 📈 实施优先级

### P0 (核心功能 - 必须实现)
- 基础的 logScreenshot API 集成
- 5种标准节点类型支持
- 简单的报告节点展示
- 与现有测试报告的基础整合

### P1 (重要功能 - 强烈建议)
- 报告模板系统
- 多受众视图切换
- 实时节点添加界面
- 错误状态专门记录功能

### P2 (增强功能 - 可选)
- 高级截图标注功能
- 批量证据管理
- 数据可视化分析
- 第三方系统集成

## 📊 成功指标

### 功能指标
- 自定义节点添加成功率 >99%
- 报告生成时间 <10秒（包含自定义节点）
- 不同视图切换响应时间 <2秒

### 用户体验指标
- 用户采用率 >80%（60天内）
- 报告质量评分提升 >50%
- 问题解决效率提升 >30%

### 技术指标
- 测试执行性能影响 <10%
- 存储空间优化率 >40%（通过压缩）
- 系统稳定性 >99.9%

## 🔍 风险评估

### 技术风险 (低)
- MidScene API 相对稳定，集成风险较小
- 主要涉及前端和数据库扩展，技术成熟
- 现有系统架构支持良好

### 用户采用风险 (中)
- 需要用户改变现有工作习惯
- 功能丰富度可能带来学习成本
- 需要充分的培训和文档支持

### 性能风险 (中)
- 大量截图可能影响系统性能
- 需要合理的存储和缓存策略
- 实时功能可能增加系统负载

---

**需求状态**: 业务分析完成，待技术设计和用户体验优化  
**下一步**: 制定详细的技术实现方案和用户界面设计  
**负责人**: 前端开发团队 + 后端开发团队  
**评审人**: 产品经理、UX设计师、QA团队负责人